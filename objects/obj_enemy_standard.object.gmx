<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_e_soldierR</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_general_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Caracteristics of the instance and variables
// Constants
varGrav = 1; // Variability of the Gravity. "1" is the normal "grav"
hsp = 0; // Initial horitzontal speed
vsp = 0; // Initial vertical speed
key_sprint = 0; // If the detonator to sprint is on or off
key_jump = 0; // If the detonator to jump is on or off
movDir = 0; if (irandom(1) = 1) { movDir = 1 } else { movDir = -1 };  // Initial walking direction:  -1=Left  0=Stopped  1=Right 
viewDir = 1; // Initial veawing direction:  -1=Left  1=Right 
allow_autojump = 1; // If the auto jump is allowed (1) or not (0)
search_place_to_jump = 1; // Place searching to jump
attack_mode = 0;
coll_line = 0; // Is there is a collision between the instance and the player
viewPlayer = 0; // If the instance can see the player
changeMovDir = 0; // If the instance is changing his movDir
countDisableAttackMode = 0; // Counter to disable attack_mode
dis_to_jump = 0; // Variable to calculate the distance to jump
preapareStopSee = 0; // Var that prepare if the instance stop seeing the player
countSearchingPlayer = 0; // Counter to do wark what happens when the instance stop seeing the player
wayBlocked_UsedToSearchPlayer = 0; // If the way is blocked and the instance needs to search the player
nearPlayer = 0; // If the instance is near the player or not (little randomized)
playerBasicAtckdmg = 0; // Variable to calculate the dmg recived form the player with the basic attack
criticDamage = 0; // Variable to calculate the dmg recived form the player with critick damage
count_setStart = 0;
antiCollapse = 0;
disToGetStoppedNearPlayer = 0;
notRandom_nearPlayer = 0; // If the player is exactly at X distance of the instance
playerVDashdmg = 0; // Variable to calculate the dmg recived form the player with the vertical dash attack
playerDashdmg = 0; // Variable to calculate the dmg recived form the player with the horizontal and 45 dash attack
playerHDashdmg = 0; // Variable to calculate the dmg recived form the player with the horizontal (0, +45 -45) dash attack
timingAttack = 0; // Counter to control the CD of the attack
TOattackPlayer = 0; // If the instance is ready or not to attack the player
globalvar finalDmgToPlayer; finalDmgToPlayer = 0; // Final damage that recive the enemy when the player attacks
timeBasAtt = 0; // Var to calculate the delay of bas attack
timingBasAtt = 0; // Var 2 to calculate the delay of bas attack
depth = -(10+irandom(1)); // Depth of the instance

    //Sprites
    spriteLoop = 0; //If the sprite have restarts after ends (1) or not (0)
    sprAtt = 0;
    sprBasicAttack = 0; 
    cont_sprBasicAttack = 0;

    ///BasicAtack from player variables
    ArmourBasicAttack =  0;
    ADdmgBasicAttack = 0;
    ResAPBasicAttack = 0;
    APdmgBasicAttack = 0;
    BasicAttackHit = 0;
    ///VDash from player variables    
    ArmourVDash =  0;
    ADdmgVDash = 0;
    ResAPVDash = 0;
    APdmgVDash = 0;
    VDashHit = 0;
    ///HDash from player variables
    ArmourHDash =  0;
    ADdmgHDash = 0;
    ResAPHDash = 0;
    APdmgHDash = 0;
    playerHDashHit = 0;
    
    ///Attack to player
    attArmour = 0;
    attAD = 0;
    attResAP = 0;
    attAP = 0;
    dmgToPlayer = 0;
    
// Variables
yHead = 54; // Y position of the head
grav = 0.1; // Gravity
jumpspeed = 15; // Jump force (recomended "15") &lt;is not the same of the obj_player&gt;)
maxSpeed = 0.75; // Standard velocity
acceleration = 0.15; // Acceleration
sprint = 0.5; // Sprint velocity
check_rise = 1; // The height of the rise that instance automatically rise.
max_jump = 40; // Max height that the instance can jump
disableAttackMode = 3; // Times that the instance have to change his dor to disable the attack_modedisToGetSlowNearPlayer = 5; // The distance at the instance starts getting slow near the player
MaxDisToGetStoppedNearPlayer = ( (sprite_get_width(spr_player_standR) + sprite_get_width(spr_e_soldierR)) / 2 ); // The max distance at the instance stops near the player
MinDisToGetStoppedNearPlayer = ( sprite_get_width(spr_player_standR) /2 ) // The min distance at the instance stops near the player
DisNearPlayerNotRandom = (sprite_get_width(spr_player_standR) + sprite_get_width(spr_e_soldierR)) // The exact distane at the intance is considered near the player without random
timeToSwapMovDir = 2; // Seconds to swap the movDir meanwhile is searching the player
timeSearchingPlayer = 6; // Seconds searching the player when the instance stoop seeing the player
maxFallVel = 10; // Max fallin velocity
playerBasicAttackHit = 0; // Check if the hability hits the instance
playerVDashHit = 0; // Check if the hability hits the instance
movDmgFromPLayer = 5; // Movment when the player hits the instance
movDmgToPLayer = 5; // Movment when he hits the player

armour = 1; // Armour
resAP = 1; //Resr AP
AD = 1;
penArm = 1;
trueAD = 1;
AP = 1;
penAP = 1; 
trueAP = 1;
ehp = 20; // HP
waitTOattackPlayer = 0.1; // Seconds waiting to attack player the first time
delayBasAtt = 0.25; // Seconds of delay to aply the dmg of the basic attack
CDattackPlayer = 2; //CD between every attack
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Environment - WORLD

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

    //Horizontal Collision
if (!place_free(x+hsp,y))
{
    while(place_free(x+sign(hsp),y,))
    {
        x += sign(hsp);
    }
    hsp = 0;
}
x += hsp;

    //Gravity
if (vsp &lt; maxFallVel) { vsp += (grav * varGrav); }

    //Vertical Collision
if (!place_free(x,y+vsp))
{
    while(place_free(x,y+sign(vsp)))
    {
        y += sign(vsp);
    }
    vsp = 0;
}
y += vsp; 


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Movments &amp; IA

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

    //Obstacle in the way
        /// If the obstacle disapears
    if ( (place_free(x+((max_jump*(2/3))  * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y)) )
    {    
        search_place_to_jump = 0 
    }       
    
    
        /// Auto rise 
    if ( (!place_free(x+((max_jump*(2/3))*movDir),y)) &amp;&amp; (place_free(x+((max_jump*(2/3))*movDir), y-(check_rise))) &amp;&amp; (allow_autojump = 0) )
    {
        y -= check_rise
    }

    
        /// Auto jump
            //// Si no hace falta saltar ya que la instancia puede solventar el obstaculo sola
    if ( (!place_free(x+((max_jump*(2/3)) * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y-(check_rise))) )
    {
        allow_autojump = 0;
    }
    else
    {
        allow_autojump = 1;
    }
    
            //// Si se ha detectado la altura a la que saltar, el salto está permitido --&gt; Calcular distancia des de la que saltar dependiendo de la velocidad, de la máxima altura que puede saltar y de la altura máxima que puede saltar.
    if 
    ( (collision_line(x, y, x+(max_jump*(2/3)), y, obj_solid, true, true)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (allow_autojump = 1) )
    ||
    ( (!place_free(x+((max_jump*(2/3)) * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (allow_autojump = 1) )
    {
        dis_to_jump = ( (2*search_place_to_jump) - (2/max_jump) * (search_place_to_jump * search_place_to_jump) ) * (abs(hsp))
    } 
    else
    {
        dis_to_jump = 0;
    }
    
    if 
    ( (!place_free(x+(dis_to_jump * movDir), y)) &amp;&amp; (!place_free(x+((dis_to_jump + (abs(hsp))) * movDir), y)) &amp;&amp; (allow_autojump = 1) &amp;&amp; (!place_free(x,y+1)))
    ||
    (hsp = 0) &amp;&amp; (!place_free(x+(1 * movDir), y)) &amp;&amp; (!place_free(x+(1 * movDir), y)) &amp;&amp; (allow_autojump = 1) &amp;&amp; (!place_free(x,y+1)) &amp;&amp; (max_jump &gt; search_place_to_jump)
    {
        key_jump = 1;
    }
    else
    {
        key_jump = 0;
    }

            //// Si se tiene que saltar pero no se ha detectado la altura a la que saltar
    while ( (!place_free(x+((max_jump*(2/3))  * movDir), y)) &amp;&amp; (!place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (allow_autojump = 1) &amp;&amp; search_place_to_jump &lt; max_jump)
    {    
        search_place_to_jump += 2; 
    }
    
        /// Change movDir if the obstacle can't be solved
    if ( (collision_line(x, y, x+(max_jump*(2/3)), y, obj_solid, true, true)) &amp;&amp; (!place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (search_place_to_jump &gt;= max_jump) )
    {
        movDir = -movDir;
        changeMovDir = 1;
    }          
    else
    {
        changeMovDir = 0;
    }
    
    if (abs(hsp) &lt; 1) &amp;&amp; (collision_line(x, y, x+(max_jump*(2/3)), y, obj_solid, true, true)) { changeMovDir = 1 } else { changeMovDir = 0 } 

    //Velocitat horitzontal
        hsp += (acceleration) * movDir;
        
        ///Frenada
        if (  (hsp != 0) &amp;&amp; (movDir = 0))
        {
            if (hsp &gt; 0) { hsp -= acceleration; }
            if (hsp &lt; 0) { hsp += acceleration; }   
        }     
        
        ///Máxima velicidad
        if (hsp &gt; maxSpeed + (key_sprint * sprint) ) { hsp = maxSpeed + (key_sprint * sprint) }
        if (hsp &lt; - ( maxSpeed + (key_sprint * sprint)) ) { hsp = -( maxSpeed + (key_sprint * sprint)) }

        ///Selección de la dirección de vista según dirección real
        if (hsp &gt; 0) { viewDir = 1; }
        if (hsp &lt; 0) { viewDir = -1; }
              
          
    //Jump
    if (!place_free(x,y+1))
    {
        vsp = ( (1 + search_place_to_jump / jumpspeed) ) * (-key_jump);
    }
    
    //BUGS
    if (movDir != 0) &amp;&amp; (hsp = 0) { vsp = ( (1 + search_place_to_jump / jumpspeed) ) }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IA Vs. Player

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

// Detect if there is a collision line between the player and the instance
if 
    ( (!collision_line(x, y-1, obj_player.x, obj_player.y-1, obj_solid, true, true)) )
    ||
    ( (!collision_line(x, y-1, obj_player.x, (obj_player.y - (sprite_get_height(Player_SpriteIndex))/2), obj_solid, true, true)) )
    ||
    ( (!collision_line(x, y-1, obj_player.x, (obj_player.y - sprite_get_height(Player_SpriteIndex)), obj_solid, true, true)) )
{
    coll_line = 0;    
}
else
{
    coll_line = 1;
   
}

// Detect if the instance can see the player or not
if (coll_line = 0)
{
    if
        (viewDir = 1) &amp;&amp; ((obj_player.x - x) &gt; 0) 
        ||
        (viewDir = -1) &amp;&amp; ((obj_player.x - x) &lt; 0)
    {
        viewPlayer = 1;
    }
}
else
{
    viewPlayer = 0;     
}

// If the instance can see the player
if (viewPlayer = 1)
{
    if (obj_player.x &gt; x) { movDir = 1 } // Chage the movDir of the player change his movDir
    if (obj_player.x &lt; x) { movDir = -1 }
    countDisableAttackMode = 0; // Counter to disable attack mode
    attack_mode = 1;
    preapareStopSee = 1;
}

// If the instance is near to the player and can see him
    // if player is near
    
    if (hsp != 0) &amp;&amp; ( (MaxDisToGetStoppedNearPlayer) &lt; (abs(x-obj_player.x)) ) { 
        disToGetStoppedNearPlayer = random_range(MinDisToGetStoppedNearPlayer, MaxDisToGetStoppedNearPlayer); 
    }
    
    if ( (disToGetStoppedNearPlayer) &gt; (abs(x-obj_player.x)) ) { 
        nearPlayer = 1; 
    } else { 
        nearPlayer = 0 
    }
    
    if ( abs(y-obj_player.y) &lt; (sprite_get_height(sprite_index) * (2/3)) ) {
        nearPlayerY = 1;
    } else {
        nearPlayerY = 0;
    }
    
    //no random distance player-instance
    if (distance_to_object(obj_player) &lt; DisNearPlayerNotRandom) { notRandom_nearPlayer = 1; } else { notRandom_nearPlayer = 0; }

    
if (viewPlayer = 1) &amp;&amp; (nearPlayer = 1)
{
    movDir = 0;
    hsp = (hsp - acceleration) * movDir;
    if (counter_TOattackPlayer &lt; (1+waitTOattackPlayer)){
        counter_TOattackPlayer += 1/120
    }
    if counter_TOattackPlayer &gt;= waitTOattackPlayer {
        TOattackPlayer = 1;
    } else {
        TOattackPlayer = 0;
    }
} else {
    counter_TOattackPlayer = 0;
}

// If the instance stop seeing the player and the way is blocked
if (changeMovDir = 1)
{
    wayBlocked_UsedToSearchPlayer = 1;
}

if (preapareStopSee = 1) &amp;&amp; (viewPlayer = 0) &amp;&amp; (wayBlocked_UsedToSearchPlayer = 1)
{
    countSearchingPlayer += (1 / room_speed) //**Every second, the game calculates "room_speed" times (120). Then 1s / 120 times.
    if (countSearchingPlayer = timeToSwapMovDir)
    {
        movDir = -movDir;
    }
    if (countSearchingPlayer &gt;= timeSearchingPlayer)
    {
        preapareStopSee = 0;
        countSearchingPlayer = 0;
    }
}
        
// If the instance can't see the player and is stopped
if (movDir = 0) &amp;&amp; (viewPlayer = 0) &amp;&amp; (changeMovDir = 0)
{    
    movDir = viewDir;
}
       


// If the instance is with attack mode
if (attack_mode = 1)
{
    key_sprint = 1;
}
else
{
    key_sprint = 0;
}

// Disable attack mode when he changes his movDir "disableAttackMode" times and is not seeing the player
if (viewPlayer = 0) &amp;&amp; (attack_mode = 1)
{
    if (changeMovDir = 1)
    {
        countDisableAttackMode += 1;
        if (countDisableAttackMode = disableAttackMode)
        {
            attack_mode = 0;
        }
    }
}



if (nearPlayer = 1) &amp;&amp; (playerBasicAttack = 1)
{
    
}
if (ehp &lt;= 0)
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Auto rise 

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

if ( (!place_free(x+hsp,y)) &amp;&amp; (place_free(x+hsp, y-check_rise)) )
{
    y -= 1;
    autoRise = 1;
} else {
    autoRise = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player attacks the instance

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

/*/ Player attacks ennemy /*/



//// player Basic attack
    // Calculate AD dmg
ArmourBasicAttack = armour - (global.playerPenArm*global.playerPenArmBasicAttack)
    if (ArmourBasicAttack &lt; 0) { ArmourBasicAttack =  0; }
ADdmgBasicAttack = (global.playerAD*global.playerADBasicAttack) - ArmourBasicAttack
    if (ADdmgBasicAttack &lt; 0) { ADdmgBasicAttack =  0; }
    // Calculate AP dmg
ResAPBasicAttack = resAP - (global.playerPenAP*global.playerPenAPBasicAttack)
    if (ResAPVDash &lt; 0) { ResAPVDash =  0; }
APdmgBasicAttack = (global.playerAP*global.playerAPBasicAttack) - ResAPBasicAttack
    if (APdmgBasicAttack &lt; 0) { APdmgBasicAttack =  0; }
    // Calculate total dmg
playerBasicAttackdmg = ( 
      ADdmgBasicAttack
    + APdmgBasicAttack
    + (global.playerTrueAD*global.playerTrueADBasicAttack) 
    + (global.playerTrueAP*global.playerTrueAPBasicAttack) 
);

if (notRandom_nearPlayer = 1) &amp;&amp; (playerBasicAttack = 1) &amp;&amp; (0 &lt; ((x-obj_player.x)*player_viewDir))
{
    playerBasicAttackHit = 1;
}
if (timing_spr_animationBasicAttack &gt; 0) &amp;&amp; (playerBasicAttackHit = 1) {
        // Movment
    hsp += (sign(x-obj_player.x) * movDmgFromPLayer);
    vsp -= (movDmgFromPLayer/4)
    
        //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityBasicAttack) )
    { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageBasicAttack);
    } else { criticDamage = 1; }
    
        //Dmg
    finalDmgToPlayer = (playerBasicAttackdmg * criticDamage);    
    ehp -= finalDmgToPlayer;
    if (criticDamage = 1) { 
        action_create_object(obj_dmgToEn,x,y-yHead-5)
    } else {
        action_create_object(obj_dmgCrToEn,x,y-yHead-5)
    }
        
        //Disable Dmg
    playerBasicAttackHit = 0;
}




//// player Vertical Dash
    // Calculate AD dmg
ArmourVDash = armour - (global.playerPenArm*global.playerPenArmVDash)
    if (ArmourVDash &lt; 0) { ArmourVDash =  0; }
ADdmgVDash = (global.playerAD*global.playerADVDash) - ArmourVDash
    if (ADdmgVDash &lt; 0) { ADdmgVDash =  0; }
    // Calculate AP dmg
ResAPVDash = resAP - (global.playerPenAP*global.playerPenAPVDash)
    if (ResAPVDash &lt; 0) { ResAPVDash =  0; }
APdmgVDash = (global.playerAP*global.playerAPVDash) - ResAPVDash
    if (APdmgVDash &lt; 0) { APdmgVDash =  0; }
    // Calculate total dmg
playerVDashdmg = ( 
      ADdmgVDash
    + APdmgVDash
    + (global.playerTrueAD*global.playerTrueADVDash) 
    + (global.playerTrueAP*global.playerTrueAPVDash) 
);

if (notRandom_nearPlayer = 1) &amp;&amp; (playerCollisionVDash = 1)
{
        // Movment
    hsp += (sign(x-obj_player.x) * movDmgFromPLayer);
    vsp -= (movDmgFromPLayer/4)
    
        //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityVDash) )
    { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageVDash);
    } 
    else 
    { 
        criticDamage = 1;
    }
    
    finalDmgToPlayer = (playerBasicAttackdmg * criticDamage);    
    ehp -= finalDmgToPlayer;
    if (criticDamage = 1) { 
        action_create_object(obj_dmgToEn,x,y-yHead-5)
    } else {
        action_create_object(obj_dmgCrToEn,x,y-yHead-5)
    }
    
    playerVDashHit = 1;
} else {
    
}



//// player Hor &amp; +-45 Dash
    // Calculate AD dmg
ArmourHDash = armour - (global.playerPenArm*global.playerPenArmHDash)
    if (ArmourHDash &lt; 0) { ArmourHDash =  0; }
ADdmgHDash = (global.playerAD*global.playerADHDash) - ArmourHDash
    if (ADdmgHDash &lt; 0) { ADdmgHDash =  0; }
    // Calculate AP dmg
ResAPHDash = resAP - (global.playerPenAP*global.playerPenAPHDash)
    if (ResAPHDash &lt; 0) { ResAPHDash =  0; }
APdmgHDash = (global.playerAP*global.playerAPHDash) - ResAPHDash
    if (APdmgHDash &lt; 0) { APdmgHDash =  0; }
    // Calculate total dmg
playerHDashdmg = ( 
      ADdmgHDash
    + APdmgHDash
    + (global.playerTrueAD*global.playerTrueADHDash) 
    + (global.playerTrueAP*global.playerTrueAPHDash) 
);


if (notRandom_nearPlayer = 1) &amp;&amp; (playerHorizontal_dash = 1) &amp;&amp; (usedHorDash = 0) &amp;&amp; (0 &lt; ((x-obj_player.x)*player_viewDir))
{  
    usedHorDash = 1;
    playerHDashHit = 1;
}

if (playerHDashHit = 1){
        // Movment
    hsp += (sign(x-obj_player.x) * movDmgFromPLayer);
    vsp -= (movDmgFromPLayer/4)

    //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityHDash) ) { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageHDash);
    } else { criticDamage = 1; }
    
        //Dmg
    finalDmgToPlayer = (playerBasicAttackdmg * criticDamage);    
    ehp -= finalDmgToPlayer;
    if (criticDamage = 1) { 
        action_create_object(obj_dmgToEn,x,y-yHead-5)
    } else {
        action_create_object(obj_dmgCrToEn,x,y-yHead-5)
    }
        
        //Disable Dmg
    playerHDashHit = 0;
}


if (notRandom_nearPlayer = 1) &amp;&amp; (playerHorizontal_dash = 1)
{} else { usedHorDash = 0; }




//// If the instance don't have life ////
if (ehp &lt;= 0)
{
    instance_destroy();
}
////---------------------------------////
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprites

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

////// Stop loop if sprLoop = 0
if (spriteLoop = 0) &amp;&amp; (image_index &gt;= image_number - 1) { image_index = image_number -1; image_speed = 0; }


// Stand
if (hsp = 0) &amp;&amp; (sprAtt = 0) {
    if (viewDir = 1) { sprite_index = spr_e_soldierR; }
    if (viewDir = -1) { sprite_index = spr_e_soldierL; }   
    spr_stand = 1; 
    image_speed = 1;
    spriteLoop = 0;
} else { 
    spr_stand = 0;  
}    

    
// Walk        
if (hsp != 0) &amp;&amp; (sprAtt = 0) {
    if (viewDir = 1) { sprite_index = spr_eBas_walkR; }
    if (viewDir = -1) { sprite_index = spr_eBas_walkL; }   
    spr_walk = 1; 
    image_speed = abs(hsp/15);
    spriteLoop = 1;
} else { 
    spr_walk = 0;  
}    
              
        
// Attack
if (sprAtt = 1) {
    if (viewDir = 1) { sprite_index = spr_en_basatckR; }
    if (viewDir = -1) { sprite_index = spr_en_basatckL; }   
    sprBasicAttack = 1; 
    image_speed = 0.1;
    spriteLoop = 0;
    if (image_index &gt;= image_number - 1) { sprAtt = 0 }
} else {
        sprBasicAttack = 0;
}
        

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Instance attacks the player

/*PAUSE GAME*/ if pause exit; /*END PAUSE GAME*/

//Calculate DMG
    attArmour = global.playerArmour - penArm;
        if attArmour &lt; 0 { attArmour = 0; }
    attAD = AD - attArmour;
        if attAD &lt; 0 { attAD = 0; }
    
    attResAP = global.playerResAP - penAP;
        if attResAP &lt; 0 { attResAP = 0; }
    attAP = AP - attResAP;
        if attAP &lt; 0 { attAP = 0; }
    dmgToPlayer = attAD + attAP + trueAD + trueAP;

// Attack
if (timingAttack &lt; CDattackPlayer) {
    timingAttack += 1/120;
}

if (timingAttack &gt;= CDattackPlayer) &amp;&amp; (TOattackPlayer = 1) &amp;&amp; (notRandom_nearPlayer = 1) &amp;&amp; (nearPlayerY = 1) {
    timingAttack = 0;
    playerAttacked = 1;
    timeBasAtt = 1;
    sprAtt = 1;
}

if timeBasAtt = 1 {
    timingBasAtt += 1/120;    
    if (timingBasAtt &gt;= delayBasAtt) {
        timingBasAtt = 0
        timeBasAtt = 0;
        //Decrease HP
        global.playerHeal -= dmgToPlayer;
        // Indicator dmg
        instance_create(x,y,obj_redScreenDmgPlayer);
        //Mov reaction
        player_hsp += (sign(obj_player.x-x) * movDmgToPLayer)/resKnockback;
        player_vsp -= (movDmgToPLayer/4)/resKnockback;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,22</point>
    <point>11,11</point>
  </PhysicsShapePoints>
</object>
