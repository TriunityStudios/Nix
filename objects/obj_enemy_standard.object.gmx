<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_general_mask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_general_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Caracteristics of the instance and variables
// Constants
global.activeEnemies += 1; // Number of the active enemies 
varGrav = 1; // Variability of the Gravity. "1" is the normal "grav"
hsp = 0; // Initial horitzontal speed
vsp = 0; // Initial vertical speed
key_sprint = 0; // If the detonator to sprint is on or off
key_jump = 0; // If the detonator to jump is on or off
movDir = 0; if (irandom(1) = 1) { movDir = 1 } else { movDir = -1 };  // Initial walking direction:  -1=Left  0=Stopped  1=Right 
viewDir = 1; // Initial veawing direction:  -1=Left  1=Right 
allow_autojump = 1; // If the auto jump is allowed (1) or not (0)
search_place_to_jump = 1; // Place searching to jump
attack_mode = 0;
coll_line = 0; // Is there is a collision between the instance and the player
viewPlayer = 0; // If the instance can see the player
changeMovDir = 0; // If the instance is changing his movDir
countDisableAttackMode = 0; // Counter to disable attack_mode
dis_to_jump = 0; // Variable to calculate the distance to jump
preapareStopSee = 0; // Var that prepare if the instance stop seeing the player
countSearchingPlayer = 0; // Counter to do wark what happens when the instance stop seeing the player
wayBlocked_UsedToSearchPlayer = 0; // If the way is blocked and the instance needs to search the player
nearPlayer = 0; // If the instance is near the player or not (little randomized)
playerBasicAtckdmg = 0; // Variable to calculate the dmg recived form the player with the basic attack
criticDamage = 0; // Variable to calculate the dmg recived form the player with critick damage
count_setStart = 0;
antiCollapse = 0;
disToGetStoppedNearPlayer = 0;
notRandom_nearPlayer = 0; // If the player is exactly at X distance of the instance
playerVDashdmg = 0; // Variable to calculate the dmg recived form the player with the vertical dash attack
playerDashdmg = 0; // Variable to calculate the dmg recived form the player with the horizontal and 45 dash attack
playerHDashdmg = 0; // Variable to calculate the dmg recived form the player with the horizontal (0, +45 -45) dash attack
    ///BasicAtack from player variables
    ArmourBasicAttack =  0;
    ADdmgBasicAttack = 0;
    ResAPBasicAttack = 0;
    APdmgBasicAttack = 0;
    ///VDash from player variables    
    ArmourVDash =  0;
    ADdmgVDash = 0;
    ResAPVDash = 0;
    APdmgVDash = 0;
    ///HDash from player variables
    ArmourHDash =  0;
    ADdmgHDash = 0;
    ResAPHDash = 0;
    APdmgHDash = 0;

// Variables
grav = 0.1; // Gravity
jumpspeed = 15; // Jump force (recomended "15") &lt;is not the same of the obj_player&gt;)
maxSpeed = 0.75; // Standard velocity
acceleration = 0.15; // Acceleration
sprint = 0.5; // Sprint velocity
check_rise = 1; // The height of the rise that instance automatically rise.
max_jump = 35; // Max height that the instance can jump
disableAttackMode = 3; // Times that the instance have to change his dor to disable the attack_modedisToGetSlowNearPlayer = 5; // The distance at the instance starts getting slow near the player
MaxDisToGetStoppedNearPlayer = ( (sprite_get_width(spr_player_standR) + sprite_get_width(spr_e_soldierR)) / 2 ); // The max distance at the instance stops near the player
MinDisToGetStoppedNearPlayer = ( sprite_get_width(spr_player_standR) /2 ) // The min distance at the instance stops near the player
DisNearPlayerNotRandom = (sprite_get_width(spr_player_standR) + sprite_get_width(spr_e_soldierR)) // The exact distane at the intance is considered near the player without random
timeToSwapMovDir = 2; // Seconds to swap the movDir meanwhile is searching the player
timeSearchingPlayer = 6; // Seconds searching the player when the instance stoop seeing the player
maxFallVel = 10; // Max fallin velocity

armour = 1; // Armour
resAP = 1; //Resr AP
ehp = 20; // HP
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Environment - WORLD
    //Horizontal Collision
if (!place_free(x+hsp,y))
{
    while(place_free(x+sign(hsp),y,))
    {
        x += sign(hsp);
    }
    hsp = 0;
}
x += hsp;

    //Gravity
if (vsp &lt; maxFallVel) { vsp += (grav * varGrav); }

    //Vertical Collision
if (!place_free(x,y+vsp))
{
    while(place_free(x,y+sign(vsp)))
    {
        y += sign(vsp);
    }
    vsp = 0;
}
y += vsp; 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Movments
    //Obstacle in the way
        /// If the obstacle disapears
    if ( (place_free(x+((max_jump*(2/3))  * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y)) )
    {    
        search_place_to_jump = 0 
    }       
    
    
        /// Auto rise 
    if ( (!place_free(x+((max_jump*(2/3))*movDir),y)) &amp;&amp; (place_free(x+((max_jump*(2/3))*movDir), y-(check_rise))) &amp;&amp; (allow_autojump = 0) )
    {
        y -= check_rise
    }

    
        /// Auto jump
            //// Si no hace falta saltar ya que la instancia puede solventar el obstaculo sola
    if ( (!place_free(x+((max_jump*(2/3)) * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y-(check_rise))) )
    {
        allow_autojump = 0;
    }
    else
    {
        allow_autojump = 1;
    }
    
            //// Si se ha detectado la altura a la que saltar, el salto está permitido --&gt; Calcular distancia des de la que saltar dependiendo de la velocidad, de la máxima altura que puede saltar y de la altura máxima que puede saltar.
    if ( (!place_free(x+((max_jump*(2/3)) * movDir), y)) &amp;&amp; (place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (allow_autojump = 1) )
    {
        dis_to_jump = ( (2*search_place_to_jump) - (2/max_jump) * (search_place_to_jump * search_place_to_jump) ) * (abs(hsp))
    } 
    else
    {
        dis_to_jump = 0;
    }
    
    if 
    ( (!place_free(x+(dis_to_jump * movDir), y)) &amp;&amp; (!place_free(x+((dis_to_jump + (abs(hsp))) * movDir), y)) &amp;&amp; (allow_autojump = 1) &amp;&amp; (!place_free(x,y+1)))
    ||
    (hsp = 0) &amp;&amp; (!place_free(x+(1 * movDir), y)) &amp;&amp; (!place_free(x+(1 * movDir), y)) &amp;&amp; (allow_autojump = 1) &amp;&amp; (!place_free(x,y+1)) &amp;&amp; (max_jump &gt; search_place_to_jump)
    {
        key_jump = 1;
    }
    else
    {
        key_jump = 0;
    }

            //// Si se tiene que saltar pero no se ha detectado la altura a la que saltar
    if ( (!place_free(x+((max_jump*(2/3))  * movDir), y)) &amp;&amp; (!place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (allow_autojump = 1) )
    {    
        search_place_to_jump += 2; 
    }
    
        /// Change movDir if the obstacle can't be solved
    if ( (!place_free(x+((max_jump*(2/3)) * movDir), y)) &amp;&amp; (!place_free(x+((max_jump*(2/3)) * movDir), y-(search_place_to_jump))) &amp;&amp; (search_place_to_jump &gt;= max_jump) )
    {
        movDir = -movDir;
        changeMovDir = 1;
    }          
    else
    {
        changeMovDir = 0;
    }
    

    //Velocitat horitzontal
        hsp += (acceleration) * movDir;
        
        ///Frenada
        if (  (hsp != 0) &amp;&amp; (movDir = 0))
        {
            if (hsp &gt; 0) { hsp -= acceleration; }
            if (hsp &lt; 0) { hsp += acceleration; }   
        }     
        
        ///Máxima velicidad
        if (hsp &gt; maxSpeed + (key_sprint * sprint) ) { hsp = maxSpeed + (key_sprint * sprint) }
        if (hsp &lt; - ( maxSpeed + (key_sprint * sprint)) ) { hsp = -( maxSpeed + (key_sprint * sprint)) }

        ///Selección de la dirección de vista según dirección real
        if (hsp &gt; 0) { viewDir = 1; }
        if (hsp &lt; 0) { viewDir = -1; }
              
          
    //Jump
    if (!place_free(x,y+1))
    {
        vsp = ( (1 + search_place_to_jump / jumpspeed) ) * (-key_jump);
    }
    
    //BUGS
    if (movDir != 0) &amp;&amp; (hsp = 0) { vsp = ( (1 + search_place_to_jump / jumpspeed) ) }
    
    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// IA Vs. Player

// Detect if there is a collision line between the player and the instance
if ( (!collision_line(x, y-1, obj_player.x, obj_player.y-1, obj_solid, true, true)) )
{
    coll_line = 0;    
}
else
{
    coll_line = 1;
   
}

// Detect if the instance can see the player or not
if (coll_line = 0)
{
    if
        (viewDir = 1) &amp;&amp; ((obj_player.x - x) &gt; 0) 
        ||
        (viewDir = -1) &amp;&amp; ((obj_player.x - x) &lt; 0)
    {
        viewPlayer = 1;
    }
}
else
{
    viewPlayer = 0;     
}

// If the instance can see the player
if (viewPlayer = 1)
{
    if (obj_player.x &gt; x) { movDir = 1 } // Chage the movDir of the player change his movDir
    if (obj_player.x &lt; x) { movDir = -1 }
    countDisableAttackMode = 0; // Counter to disable attack mode
    attack_mode = 1;
    preapareStopSee = 1;
}

// If the instance is near to the player and can see him
    // if player is near
    
    if (hsp != 0) &amp;&amp; ( (MaxDisToGetStoppedNearPlayer) &lt; (abs(x-obj_player.x)) ) { disToGetStoppedNearPlayer = random_range(MinDisToGetStoppedNearPlayer, MaxDisToGetStoppedNearPlayer); }
    
    if ( (disToGetStoppedNearPlayer) &gt; (abs(x-obj_player.x)) ) { nearPlayer = 1; } else { nearPlayer = 0 }

if (viewPlayer = 1) &amp;&amp; (nearPlayer = 1)
{
    movDir = 0;
    hsp = (hsp - acceleration) * movDir;
}

// If the instance stop seeing the player and the way is blocked
if (changeMovDir = 1)
{
    wayBlocked_UsedToSearchPlayer = 1;
}

if (preapareStopSee = 1) &amp;&amp; (viewPlayer = 0) &amp;&amp; (wayBlocked_UsedToSearchPlayer = 1)
{
    countSearchingPlayer += (1 / room_speed) //**Every second, the game calculates "room_speed" times (120). Then 1s / 120 times.
    if (countSearchingPlayer = timeToSwapMovDir)
    {
        movDir = -movDir;
    }
    if (countSearchingPlayer &gt;= timeSearchingPlayer)
    {
        preapareStopSee = 0;
        countSearchingPlayer = 0;
    }
}
        
// If the instance can't see the player and is stopped
if (movDir = 0) &amp;&amp; (viewPlayer = 0) &amp;&amp; (changeMovDir = 0)
{    
    movDir = viewDir;
}
       


// If the instance is with attack mode
if (attack_mode = 1)
{
    key_sprint = 1;
}
else
{
    key_sprint = 0;
}

// Disable attack mode when he changes his movDir "disableAttackMode" times and is not seeing the player
if (viewPlayer = 0) &amp;&amp; (attack_mode = 1)
{
    if (changeMovDir = 1)
    {
        countDisableAttackMode += 1;
        if (countDisableAttackMode = disableAttackMode)
        {
            attack_mode = 0;
        }
    }
}



if (nearPlayer = 1) &amp;&amp; (playerBasicAttack = 1)
{
    
}
if (ehp &lt;= 0)
{
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Auto rise 
if ( (!place_free(x+(1*movDir),y)) &amp;&amp; (place_free(x+(1*movDir), y-check_rise)) )
{
    y -= 1
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player attacks the instance
if (distance_to_object(obj_player) &lt; DisNearPlayerNotRandom) { notRandom_nearPlayer = 1; } else { notRandom_nearPlayer = 0; }


/*/ Player attacks ennemy /*/

//// player Basic attack
    // Calculate AD dmg
ArmourBasicAttack = armour - (global.playerPenArm*global.playerPenArmBasicAttack)
    if (ArmourBasicAttack &lt; 0) { ArmourBasicAttack =  0; }
ADdmgBasicAttack = (global.playerAD*global.playerADBasicAttack) - ArmourBasicAttack
    if (ADdmgBasicAttack &lt; 0) { ADdmgBasicAttack =  0; }
    // Calculate AP dmg
ResAPBasicAttack = resAP - (global.playerPenAP*global.playerPenAPBasicAttack)
    if (ResAPVDash &lt; 0) { ResAPVDash =  0; }
APdmgBasicAttack = (global.playerAP*global.playerAPBasicAttack) - ResAPBasicAttack
    if (APdmgBasicAttack &lt; 0) { APdmgBasicAttack =  0; }
    // Calculate total dmg
playerBasicAttackdmg = ( 
      ADdmgBasicAttack
    + APdmgBasicAttack
    + (global.playerTrueAD*global.playerTrueADBasicAttack) 
    + (global.playerTrueAP*global.playerTrueAPBasicAttack) 
);

if (notRandom_nearPlayer = 1) &amp;&amp; (playerBasicAttack = 1) &amp;&amp; (0 &lt; ((x-obj_player.x)*player_viewDir))
{
    //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityBasicAttack) )
    { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageBasicAttack);
    } else { criticDamage = 1; }
    
    ehp -= (playerBasicAttackdmg * criticDamage);
}



//// player Vertical Dash
    // Calculate AD dmg
ArmourVDash = armour - (global.playerPenArm*global.playerPenArmVDash)
    if (ArmourVDash &lt; 0) { ArmourVDash =  0; }
ADdmgVDash = (global.playerAD*global.playerADVDash) - ArmourVDash
    if (ADdmgVDash &lt; 0) { ADdmgVDash =  0; }
    // Calculate AP dmg
ResAPVDash = resAP - (global.playerPenAP*global.playerPenAPVDash)
    if (ResAPVDash &lt; 0) { ResAPVDash =  0; }
APdmgVDash = (global.playerAP*global.playerAPVDash) - ResAPVDash
    if (APdmgVDash &lt; 0) { APdmgVDash =  0; }
    // Calculate total dmg
playerVDashdmg = ( 
      ADdmgVDash
    + APdmgVDash
    + (global.playerTrueAD*global.playerTrueADVDash) 
    + (global.playerTrueAP*global.playerTrueAPVDash) 
);

if (notRandom_nearPlayer = 1) &amp;&amp; (playerCollisionVDash = 1)
{
    //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityVDash) )
    { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageVDash);
    } 
    else 
    { 
        criticDamage = 1;
    }
    
    ehp -= (playerVDashdmg * criticDamage);
}



//// player Hor &amp; +-45 Dash
    // Calculate AD dmg
ArmourHDash = armour - (global.playerPenArm*global.playerPenArmHDash)
    if (ArmourHDash &lt; 0) { ArmourHDash =  0; }
ADdmgHDash = (global.playerAD*global.playerADHDash) - ArmourHDash
    if (ADdmgHDash &lt; 0) { ADdmgHDash =  0; }
    // Calculate AP dmg
ResAPHDash = resAP - (global.playerPenAP*global.playerPenAPHDash)
    if (ResAPHDash &lt; 0) { ResAPHDash =  0; }
APdmgHDash = (global.playerAP*global.playerAPHDash) - ResAPHDash
    if (APdmgHDash &lt; 0) { APdmgHDash =  0; }
    // Calculate total dmg
playerHDashdmg = ( 
      ADdmgHDash
    + APdmgHDash
    + (global.playerTrueAD*global.playerTrueADHDash) 
    + (global.playerTrueAP*global.playerTrueAPHDash) 
);


if (notRandom_nearPlayer = 1) &amp;&amp; (playerHorizontal_dash = 1) &amp;&amp; (usedHorDash = 0)
{
    //Calculate critic
    if (irandom(100) &lt; (global.playerCritickProbability*global.playerCritickProbabilityHDash) )
    { 
        criticDamage = (global.playerCritickDamage*global.playerCritickDamageHDash);
    } 
    else 
    { 
        criticDamage = 1;
    }
    
    usedHorDash = 1;
    ehp -= (playerHDashdmg * criticDamage);
}

if (notRandom_nearPlayer = 1) &amp;&amp; (playerHorizontal_dash = 1)
{} else { usedHorDash = 0; }










//// If the instance don't have life ////
if (ehp &lt;= 0)
{
    global.activeEnemies -= 1;
    instance_destroy();
}
////---------------------------------////
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprites
        if (movDir = 1)
        {
            sprite_index = spr_e_soldierR;
            image_speed = 0.03;
        }
        if (movDir = -1)
        {
            sprite_index = spr_e_soldierL;
            image_speed = 0.03;
        } 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,22</point>
    <point>11,11</point>
  </PhysicsShapePoints>
</object>
